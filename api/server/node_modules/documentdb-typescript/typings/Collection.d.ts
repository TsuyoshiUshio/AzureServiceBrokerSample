import * as _DocumentDB from "./_DocumentDB";
import { Database } from "./Database";
import { Client } from "./Client";
import { DocumentStream } from "./DocumentStream";
/** Modes that can be used for storing resources in a collection */
export declare enum StoreMode {
    Upsert = 0,
    CreateOnly = 1,
    UpdateOnly = 2,
    UpdateOnlyIfNoChange = 3,
}
/** Combined option objects for operations that may invoke multiple network calls */
export declare type AllOptions = _DocumentDB.FeedOptions & _DocumentDB.RequestOptions;
/** Represents a DocumentDB collection */
export declare class Collection {
    /** Refer to a collection by name, from given database */
    constructor(id: string, database: Database);
    /** Refer to a collection by name, from given database (by name), connected through given client */
    constructor(id: string, dbName: string, client: Client);
    /** Refer to a collection by name, from given database (by name), using given URL and master key (implicitly creates a new client instance) */
    constructor(id: string, dbName: string, url?: string, masterKey?: string);
    /** The name of the collection that this instance refers to */
    readonly id: string;
    /** The database used for all operations */
    readonly database: Database;
    /** The partial resource URI for this database, i.e. `"/dbs/.../colls/..."` */
    readonly path: string;
    /** Open and validate the connection, check that this collection exists */
    openAsync(maxRetries?: number, options?: AllOptions): Promise<this>;
    /** Open and validate the connection, find or create collection resource (does not create the database) */
    openOrCreateAsync(createThroughput?: number, indexingPolicy?: _DocumentDB.IndexingPolicy, defaultTtl?: number, maxRetries?: number, options?: AllOptions): Promise<this>;
    /** Open and validate the connection, find or create collection resource (also creates the database if needed) */
    openOrCreateDatabaseAsync(createThroughput?: number, indexingPolicy?: _DocumentDB.IndexingPolicy, defaultTtl?: number, maxRetries?: number): Promise<this>;
    /** Get offer (throughput provisioning) information */
    getOfferInfoAsync(maxRetries?: number, options?: AllOptions): Promise<_DocumentDB.OfferResource>;
    /** Set provisioned throughput */
    setOfferInfoAsync(throughput: number): Promise<void>;
    /** Delete this collection */
    deleteAsync(maxRetries?: number, options?: AllOptions): Promise<void>;
    /** Create or update the document with given data (must include an `.id` or `._self` property if store mode is `UpdateOnly`, and must also include an `_etag` property if store mode is `UpdateOnlyIfNoChange`); returns the stored data as a plain object, including meta properties such as `._etag` and `._self` */
    storeDocumentAsync<T extends Partial<_DocumentDB.DocumentResource>>(data: T, mode?: StoreMode, maxRetries?: number, options?: AllOptions): Promise<T & _DocumentDB.DocumentResource>;
    /** Find the document with given ID */
    findDocumentAsync<ResultT extends {}>(id: string, maxRetries?: number, options?: AllOptions): Promise<ResultT & _DocumentDB.DocumentResource>;
    /** Reload given document from the database using its `._self` property */
    findDocumentAsync<ResultT extends {}>(doc: {
        _self: string;
    }, maxRetries?: number, options?: AllOptions): Promise<ResultT & _DocumentDB.DocumentResource>;
    /** Find the document with exactly the same values for all properties (i.e. where _all_ own properties of the given object match exactly) */
    findDocumentAsync<ResultT extends {}>(obj: Partial<ResultT>, maxRetries?: number, options?: AllOptions): Promise<ResultT & _DocumentDB.DocumentResource>;
    /** Check if a document with given ID exists (without reading the document) */
    existsAsync(id: string, maxRetries?: number, options?: AllOptions): Promise<boolean>;
    /** Check if a document with given properties exists (i.e. where _all_ own properties of the given object match exactly) */
    existsAsync(obj: {}, maxRetries?: number, options?: AllOptions): Promise<boolean>;
    /** Query documents in this collection using a SQL query string, or SQL query object (i.e. `{ query: "...", parameters: [{ name: "@...", value: ... }, ...] }`) */
    queryDocuments<ResultT>(query: _DocumentDB.SqlQuery, batchSize?: number): DocumentStream<ResultT>;
    /** Query documents in this collection using a SQL query string, or SQL query object (i.e. `{ query: "...", parameters: [{ name: "@...", value: ... }, ...] }`) */
    queryDocuments<ResultT>(query: _DocumentDB.SqlQuery, options?: AllOptions): DocumentStream<ResultT>;
    /** Query all documents in this collection */
    queryDocuments<ResultT extends {}>(query?: undefined, batchSize?: number): DocumentStream<ResultT & _DocumentDB.DocumentResource>;
    /** Query all documents in this collection */
    queryDocuments<ResultT extends {}>(query?: undefined, options?: AllOptions): DocumentStream<ResultT & _DocumentDB.DocumentResource>;
    /** Delete the document with given ID */
    deleteDocumentAsync(id: string, maxRetries?: number, options?: AllOptions): Promise<void>;
    /** Delete the given document (must have a `_self` property, e.g. the result of `storeDocumentAsync` or `findDocumentAsync`, OR a valid `id` property, note that other properties are NOT matched against the document to be deleted) */
    deleteDocumentAsync(doc: {
        _self: string;
    } | {
        id: string;
    }, maxRetries?: number, options?: AllOptions): Promise<void>;
}
