/** Represents asynchronously loaded query result sets as a stream; the type parameter represents the query result type, i.e. a full document resource type for `SELECT * FROM` queries, an object with only projected properties for `SELECT x, y, ... FROM` queries, or even a scalar value for `SELECT VALUE ... FROM` queries */
export declare class DocumentStream<T> implements AsyncIterable<T> {
    private _collection;
    private _uid;
    private _qiP;
    /** Private constructor */
    private constructor(_collection, _uid, _qiP);
    /** Timeout (ms) used for all operations; set to the Client timeout initially, set this to a large number if reading a large result set using `toArray` */
    timeout: number;
    /** Get the next result (asynchronously), if any; promise resolves to the result, or to `null` if there are no results left in the set, or is rejected if an error occurred; subsequent calls to this function will return promises for results after the current result (i.e. requests are queued) */
    read(): Promise<T | null>;
    /** This property makes the entire instance usable as an async iterator */
    [Symbol.asyncIterator]: () => this;
    /** Get the next result (asynchronously), if any; promise resolves to a `{ value, done }` pair, or is rejected if an error occurred; subsequent calls to this function will return promises for results after the current result (i.e. requests are queued) */
    next(): Promise<IteratorResult<T>>;
    /** Call a function for each result, until all results have been processed or the callback returns `false` or throws an error; returned promise resolves to true if all results have been processed, or false otherwise, or is rejected if an error occurred */
    forEach(f: (doc: T) => any): PromiseLike<boolean>;
    /** Call a function for each result; returns a promise for an array with all return values, which is resolved only when all results have been processed, or is rejected if the callback throws an error */
    mapAsync(f: (doc: T) => void): Promise<void[]>;
    /** Reset the stream to the beginning of the set (synchronously); returns the stream itself */
    reset(): this;
    /** Reset the stream to the beginning of the set (asynchronously, i.e. after all queued operations have completed) */
    resetAsync(): void;
    /** Load all results into an array */
    toArray(): Promise<T[]>;
}
