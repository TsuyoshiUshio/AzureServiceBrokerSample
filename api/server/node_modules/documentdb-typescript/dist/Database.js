"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
Object.defineProperty(exports, "__esModule", { value: true });
const Client_1 = require("./Client");
const Util_1 = require("./Util");
const Collection_1 = require("./Collection");
/** Represents a DocumentDB database */
class Database {
    constructor(id, ...info) {
        if (!id)
            throw new Error("Databases must have a name");
        this.id = id;
        if (info[0] instanceof Client_1.Client) {
            // store client reference and optional self link (given by client)
            this.client = info[0];
            this._self = info[1];
        }
        else {
            // create client using given auth data
            this.client = new Client_1.Client(info[0], info[1]);
        }
    }
    /** The partial resource URI for this database, i.e. `"/dbs/..."` */
    get path() {
        return this._self || "dbs/" + encodeURIComponent(this.id) + "/";
    }
    /** Open and validate the connection, check that this database exists */
    openAsync(maxRetries) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._self)
                return this;
            yield this.client.openAsync(maxRetries);
            // find this database's self link from client's list of databases
            var dbs = yield this.client.listDatabasesAsync(false, maxRetries);
            dbs.some(r => (r.id === this.id ? !!(this._self = r._self) : false));
            if (!this._self)
                throw new Error("Database does not exist: " + this.id);
            return this;
        });
    }
    /** Open and validate connection, find or create database resource */
    openOrCreateAsync(maxRetries = 3) {
        return __awaiter(this, void 0, void 0, function* () {
            if (this._self)
                return this;
            yield this.client.openAsync(maxRetries);
            // find this database's self link from client's list of databases
            var forceReload = false;
            while (true) {
                var dbs = yield this.client.listDatabasesAsync(forceReload);
                dbs.some(db => (db.id === this.id ? !!(this._self = db._self) : false));
                if (!this._self) {
                    try {
                        // create the database now
                        yield this.client.createDatabaseAsync(this.id);
                        return this;
                    }
                    catch (err) {
                        if (err.code <= 404 || maxRetries-- <= 0)
                            throw err;
                        // otherwise, continue and maybe pick up the created DB
                        // in the next iteration
                        yield Util_1.sleepAsync(100);
                        forceReload = true;
                    }
                }
                return this;
            }
        });
    }
    /** Get a list of Collection instances for this database */
    listCollectionsAsync(maxRetries, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.openAsync(maxRetries);
            // get all collections using readCollections
            let tryListAll = (callback) => this.client.log("Reading collections in " + this.id) &&
                this.client.documentClient.readCollections(this._self, options)
                    .toArray(callback);
            var resources = yield Util_1.curryPromise(tryListAll, this.client.timeout, maxRetries)();
            // map resources to Collection instances
            return resources.map(r => new Collection_1.Collection(r.id, this, r._self));
        });
    }
    /** Delete this database */
    deleteAsync(maxRetries, options) {
        return __awaiter(this, void 0, void 0, function* () {
            yield this.openAsync(maxRetries);
            // use deleteDatabase to delete the database (duh...)
            let tryDelete = (callback) => this.client.log("Deleting database: " + this.id) &&
                this.client.documentClient.deleteDatabase(this._self, options, callback);
            yield Util_1.curryPromise(tryDelete, this.client.timeout)();
            delete this._self;
        });
    }
}
exports.Database = Database;
